<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LSF Turbo Mode</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        body { 
            margin: 0; padding: 0; overflow: hidden; background-color: #000;
            width: 100vw; height: 100vh; font-family: sans-serif;
            display: flex; justify-content: center; align-items: center;
        }

        /* PLEIN Ã‰CRAN TOTAL */
        canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; /* Remplit l'Ã©cran */
            transform: rotateY(180deg); z-index: 1;
        }

        /* TEXTE FLOTTANT */
        .hud-container {
            position: absolute; bottom: 20%; width: 100%;
            z-index: 10; display: flex; flex-direction: column; align-items: center; 
            pointer-events: none;
        }

        .word-bubble {
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px);
            padding: 10px 40px; border-radius: 50px;
            border: 2px solid #3b82f6; transition: all 0.2s;
        }

        .detected-word {
            color: white; font-size: 2.5rem; font-weight: 800;
            text-transform: uppercase; margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .debug-fps {
            position: absolute; top: 10px; left: 10px; color: lime; z-index: 20; font-size: 12px;
        }

        .loader {
            position: absolute; z-index: 30; background: #000; color: #fff;
            padding: 20px; border-radius: 10px; border: 1px solid #333;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        
        video { display: none; }
    </style>
</head>
<body>

    <div class="loader" id="loader">DÃ©marrage Mode Turbo...</div>
    <div class="debug-fps" id="fps">FPS: 0</div>

    <video id="webcam" playsinline muted autoplay></video>
    <canvas id="output_canvas"></canvas>

    <div class="hud-container">
        <div class="word-bubble" id="bubble">
            <h1 class="detected-word" id="word-out">...</h1>
        </div>
    </div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        const wordOut = document.getElementById('word-out');
        const loader = document.getElementById('loader');
        const bubble = document.getElementById('bubble');
        const fpsText = document.getElementById('fps');

        let lastDetected = "";
        let detectionStart = 0;
        let lastFrameTime = 0;
        const HOLD_TIME = 600; 

        // 1. CONFIGURATION ULTRA LÃ‰GÃˆRE (HANDS ONLY)
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,           // Une seule main (plus rapide)
            modelComplexity: 0,       // 0 = Vitesse maximale
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 2. RENDU
        function onResults(results) {
            loader.style.display = 'none';
            
            // Calcul FPS
            const now = Date.now();
            const fps = 1000 / (now - lastFrameTime);
            lastFrameTime = now;
            fpsText.innerText = `FPS: ${Math.round(fps)}`;

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#3b82f6', lineWidth: 3});
                drawLandmarks(ctx, lm, {color: 'white', lineWidth: 1, radius: 2});
                
                let word = analyze(lm);
                display(word);
            } else {
                display(""); // Pas de main
            }
            ctx.restore();
        }

        // 3. LOGIQUE SIMPLIFIÃ‰E (ZONES D'Ã‰CRAN)
        function analyze(lm) {
            // lm[8] = Bout de l'index
            // lm[0] = Poignet
            // Les coordonnÃ©es Y vont de 0 (Haut) Ã  1 (Bas)

            const yPos = lm[8].y; // Hauteur de la main
            const fingers = countFingers(lm);

            // --- RÃˆGLES BASÃ‰ES SUR LA HAUTEUR ---

            // ZONE HAUTE (Y < 0.45) -> VISAGE (Bonjour / Manger)
            if (yPos < 0.45) {
                // Si main ouverte (>= 3 doigts) -> BONJOUR
                if (fingers >= 3) return "BONJOUR ðŸ‘‹";
                
                // Si main fermÃ©e/pince (<= 2 doigts) -> MANGER
                // On ajoute une vÃ©rif que le pouce est proche de l'index pour la "pince"
                if (fingers <= 2) return "MANGER ðŸŽ";
            }

            // ZONE BASSE (Y > 0.55) -> TORSE (Moi / DÃ©solÃ©)
            else if (yPos > 0.55) {
                // Si index levÃ© (PointÃ©) -> MOI
                // On vÃ©rifie que l'index est le doigt le plus haut
                if (lm[8].y < lm[6].y && lm[12].y > lm[10].y) return "MOI ðŸ‘¤";

                // Si poing fermÃ© (0 ou 1 doigt) -> DÃ‰SOLÃ‰
                if (fingers <= 1) return "DÃ‰SOLÃ‰ ðŸ™";
            }

            return null;
        }

        function countFingers(lm) {
            let count = 0;
            // Index, Majeur, Annulaire, Auriculaire (Si le bout est plus haut que la base)
            if (lm[8].y < lm[6].y) count++;
            if (lm[12].y < lm[10].y) count++;
            if (lm[16].y < lm[14].y) count++;
            if (lm[20].y < lm[18].y) count++;
            return count;
        }

        function display(word) {
            if (!word) {
                if(Date.now() - detectionStart > 300) {
                    wordOut.innerText = "...";
                    bubble.style.borderColor = "#3b82f6";
                }
                return;
            }

            if (word === lastDetected) {
                const dur = Date.now() - detectionStart;
                wordOut.innerText = word;
                if (dur > HOLD_TIME) {
                    bubble.style.borderColor = "#10b981"; // Vert
                    if (navigator.vibrate) navigator.vibrate(50);
                }
            } else {
                lastDetected = word;
                detectionStart = Date.now();
                wordOut.innerText = word;
                bubble.style.borderColor = "#3b82f6"; // Bleu
            }
        }

        // 4. CAMERA BASSE RÃ‰SOLUTION (Le secret de la fluiditÃ©)
        async function startCamera() {
            try {
                // On demande du 320x240. C'est petit, donc ultra rapide Ã  calculer.
                // Le CSS (object-fit: cover) l'agrandira pour remplir l'Ã©cran.
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: "user",
                        width: { ideal: 320 }, 
                        height: { ideal: 240 },
                        frameRate: { ideal: 30 }
                    }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    loop();
                };
            } catch (err) {
                alert("Erreur CamÃ©ra: " + err.name);
            }
        }

        // Boucle avec contrÃ´le de vitesse (Si Ã§a chauffe trop)
        let lastRun = 0;
        async function loop() {
            const now = Date.now();
            // Limite Ã  20 analyses par seconde max pour laisser respirer le tÃ©lÃ©phone
            if (now - lastRun > 50) { 
                await hands.send({image: video});
                lastRun = now;
            }
            requestAnimationFrame(loop);
        }

        startCamera();
    </script>
</body>
</html>